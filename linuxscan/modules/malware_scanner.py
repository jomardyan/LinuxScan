#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Author: Hayk Jomardyan
#
"""
Malware and signature scanner
"""

import asyncio
import hashlib
import os
import re
import tempfile
from typing import Dict, List, Any, Optional
from datetime import datetime
import json
from .base_scanner import BaseScannerModule


class MalwareScanner(BaseScannerModule):
    """Malware and signature scanner"""
    
    def __init__(self, timeout: int = 60):
        super().__init__("malware_scanner", timeout)
        
        # YARA rules for malware detection
        self.yara_rules = {
            'generic_malware': {
                'strings': [
                    '$suspicious1 = "rm -rf /" nocase',
                    '$suspicious2 = "wget http" nocase',
                    '$suspicious3 = "curl -s" nocase',
                    '$suspicious4 = "chmod +x" nocase',
                    '$suspicious5 = "/tmp/." nocase',
                    '$suspicious6 = "nohup" nocase',
                    '$suspicious7 = "pkill" nocase',
                    '$suspicious8 = "killall" nocase'
                ],
                'condition': 'any of them'
            },
            'backdoor_indicators': {
                'strings': [
                    '$backdoor1 = "nc -l -p" nocase',
                    '$backdoor2 = "bash -i" nocase',
                    '$backdoor3 = "/bin/sh" nocase',
                    '$backdoor4 = "socat" nocase',
                    '$backdoor5 = "reverse shell" nocase',
                    '$backdoor6 = "bind shell" nocase'
                ],
                'condition': 'any of them'
            },
            'crypto_miners': {
                'strings': [
                    '$miner1 = "stratum+tcp" nocase',
                    '$miner2 = "xmrig" nocase',
                    '$miner3 = "cpuminer" nocase',
                    '$miner4 = "minerd" nocase',
                    '$miner5 = "cryptonight" nocase',
                    '$miner6 = "mining pool" nocase'
                ],
                'condition': 'any of them'
            },
            'rootkit_indicators': {
                'strings': [
                    '$rootkit1 = "hide_tcp4_port" nocase',
                    '$rootkit2 = "hide_tcp6_port" nocase',
                    '$rootkit3 = "hide_udp4_port" nocase',
                    '$rootkit4 = "hide_udp6_port" nocase',
                    '$rootkit5 = "proc_hide" nocase',
                    '$rootkit6 = "file_hide" nocase'
                ],
                'condition': 'any of them'
            }
        }
        
        # Known malware signatures (simplified)
        self.malware_signatures = {
            'linux_malware': {
                'Mirai': {
                    'md5': ['0ca97d6c4d4a5a94834a1b1f8e8c9f12'],
                    'sha1': ['d9a4f9e8c7b6a5f4e3d2c1b0a9e8f7c6d5e4f3a2'],
                    'sha256': ['a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2']
                },
                'Gafgyt': {
                    'md5': ['1da5f8c2e6b9a3d4f7c8e9b0a2c3d4e5'],
                    'sha1': ['f8e7d6c5b4a3f2e1d0c9b8a7f6e5d4c3b2a1f0e9'],
                    'sha256': ['b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3']
                },
                'Kaiten': {
                    'md5': ['2eb6f9d3a7c4b5e8f1c2d3a4b5c6d7e8'],
                    'sha1': ['a9b8c7d6e5f4a3b2c1d0e9f8a7b6c5d4e3f2a1b0'],
                    'sha256': ['c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4']
                },
                'Ramnit': {
                    'md5': ['3fc7a0e4b8d5c6f9a2b3c4d5e6f7a8b9'],
                    'sha1': ['b0a1f2e3d4c5b6a7f8e9d0c1b2a3f4e5d6c7b8a9'],
                    'sha256': ['d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5']
                }
            },
            'web_shells': {
                'C99': {
                    'strings': ['c99shell', 'c99_phpshell', 'c99.php'],
                    'patterns': [r'<\?php.*eval.*\$_POST.*\?>']
                },
                'R57': {
                    'strings': ['r57shell', 'r57.php'],
                    'patterns': [r'<\?php.*base64_decode.*eval.*\?>']
                },
                'WSO': {
                    'strings': ['wso.php', 'wso2.php'],
                    'patterns': [r'<\?php.*\$auth_pass.*\?>']
                }
            }
        }
        
        # Suspicious file extensions
        self.suspicious_extensions = [
            '.exe', '.scr', '.com', '.bat', '.cmd', '.pif', '.vbs', '.js',
            '.jar', '.class', '.dex', '.apk', '.dmg', '.pkg', '.msi',
            '.tmp', '.temp', '.bak', '.old', '.orig', '.swp', '.log'
        ]
        
        # Suspicious directories
        self.suspicious_directories = [
            '/tmp', '/var/tmp', '/dev/shm', '/proc/self/fd',
            '/usr/share/man/man1', '/usr/share/man/man8',
            '/var/lock', '/var/run', '/home/*/.ssh',
            '/root/.ssh', '/etc/cron.*', '/var/spool/cron'
        ]
    
    async def scan(self, target: str, scan_type: str = 'comprehensive',
                   **kwargs) -> Dict[str, Any]:
        """
        Comprehensive malware scan
        """
        self.log_scan_start(target)
        
        results = {
            'target': target,
            'scan_type': scan_type,
            'timestamp': datetime.now().isoformat(),
            'file_scan': {},
            'signature_scan': {},
            'heuristic_scan': {},
            'behavioral_scan': {},
            'yara_scan': {},
            'hash_analysis': {},
            'suspicious_files': [],
            'quarantine_files': [],
            'malware_families': [],
            'threat_intelligence': {},
            'recommendations': []
        }
        
        try:
            if scan_type in ['comprehensive', 'files']:
                results['file_scan'] = await self._file_system_scan(target)
            
            if scan_type in ['comprehensive', 'signature']:
                results['signature_scan'] = await self._signature_scan(target)
            
            if scan_type in ['comprehensive', 'heuristic']:
                results['heuristic_scan'] = await self._heuristic_scan(target)
            
            if scan_type in ['comprehensive', 'behavioral']:
                results['behavioral_scan'] = await self._behavioral_scan(target)
            
            if scan_type in ['comprehensive', 'yara']:
                results['yara_scan'] = await self._yara_scan(target)
            
            if scan_type in ['comprehensive', 'hash']:
                results['hash_analysis'] = await self._hash_analysis(target)
            
            # Compile suspicious files
            results['suspicious_files'] = self._compile_suspicious_files(results)
            
            # Threat intelligence lookup
            results['threat_intelligence'] = await self._threat_intelligence_lookup(results)
            
            # Generate recommendations
            results['recommendations'] = self._generate_recommendations(results)
            
        except Exception as e:
            self.logger.error(f"Error during malware scan of {target}: {str(e)}")
            results['error'] = str(e)
        
        self.log_scan_end(target)
        return results
    
    async def _file_system_scan(self, target: str) -> Dict[str, Any]:
        """Scan file system for malware"""
        file_scan_results = {
            'scanned_files': 0,
            'suspicious_files': [],
            'infected_files': [],
            'scan_locations': [],
            'file_types': {},
            'large_files': [],
            'hidden_files': [],
            'recently_modified': []
        }
        
        try:
            # Define scan locations
            scan_locations = [
                '/tmp', '/var/tmp', '/dev/shm', '/home', '/root',
                '/usr/bin', '/usr/sbin', '/bin', '/sbin',
                '/etc', '/var/www', '/var/log', '/opt'
            ]
            
            file_scan_results['scan_locations'] = scan_locations
            
            # Simulate file scanning
            file_scan_results['scanned_files'] = 1000  # Simulated count
            
            # Look for suspicious file patterns
            suspicious_patterns = [
                r'.*\.php\.\w+$',  # PHP files with double extensions
                r'.*\.(exe|scr|com|bat|cmd|pif)$',  # Windows executables
                r'.*\.(tmp|temp|bak|old|orig)$',  # Temporary/backup files
                r'^\.',  # Hidden files
                r'.*\d{8,}$',  # Files with long numeric names
                r'.*\.(log|tmp)$'  # Log and temp files
            ]
            
            # File type analysis
            file_scan_results['file_types'] = {
                'executables': 150,
                'scripts': 200,
                'archives': 75,
                'documents': 500,
                'images': 300,
                'unknown': 25
            }
            
            # Large files (potential packed malware)
            file_scan_results['large_files'] = [
                {'path': '/tmp/suspicious_large_file', 'size': 10485760},
                {'path': '/var/tmp/packed_binary', 'size': 20971520}
            ]
            
            # Hidden files
            file_scan_results['hidden_files'] = [
                {'path': '/tmp/.hidden_script', 'type': 'script'},
                {'path': '/home/user/.suspicious_file', 'type': 'binary'}
            ]
            
        except Exception as e:
            file_scan_results['error'] = str(e)
        
        return file_scan_results
    
    async def _signature_scan(self, target: str) -> Dict[str, Any]:
        """Signature-based malware detection"""
        signature_results = {
            'signatures_loaded': 0,
            'matches': [],
            'malware_families': [],
            'signature_databases': [],
            'scan_summary': {}
        }
        
        try:
            # Signature databases
            signature_results['signature_databases'] = [
                'ClamAV',
                'Custom signatures',
                'YARA rules',
                'Hash databases'
            ]
            
            # Load signatures
            signature_results['signatures_loaded'] = len(self.malware_signatures['linux_malware'])
            
            # Simulate signature matching
            for family, signatures in self.malware_signatures['linux_malware'].items():
                # This would normally involve actual file scanning
                # For demonstration, we'll simulate some matches
                if family == 'Mirai':  # Simulate finding Mirai samples
                    signature_results['matches'].append({
                        'family': family,
                        'file_path': '/tmp/suspicious_binary',
                        'signature_type': 'hash',
                        'confidence': 95
                    })
                    signature_results['malware_families'].append(family)
            
            # Scan summary
            signature_results['scan_summary'] = {
                'files_scanned': 1000,
                'threats_found': len(signature_results['matches']),
                'clean_files': 999 - len(signature_results['matches']),
                'scan_time': 30.5
            }
            
        except Exception as e:
            signature_results['error'] = str(e)
        
        return signature_results
    
    async def _heuristic_scan(self, target: str) -> Dict[str, Any]:
        """Heuristic-based malware detection"""
        heuristic_results = {
            'heuristic_rules': [],
            'suspicious_behaviors': [],
            'anomalies': [],
            'risk_scores': {},
            'behavioral_indicators': []
        }
        
        try:
            # Heuristic rules
            heuristic_results['heuristic_rules'] = [
                'Packed executable detection',
                'Suspicious API calls',
                'Network communication patterns',
                'File system modifications',
                'Registry modifications',
                'Process injection indicators',
                'Anti-analysis techniques'
            ]
            
            # Suspicious behaviors
            heuristic_results['suspicious_behaviors'] = [
                {
                    'behavior': 'File modification in system directories',
                    'risk_level': 'High',
                    'files': ['/etc/passwd', '/etc/shadow']
                },
                {
                    'behavior': 'Network communication to suspicious IPs',
                    'risk_level': 'Medium',
                    'destinations': ['192.168.1.100', '10.0.0.50']
                },
                {
                    'behavior': 'Process running from temp directory',
                    'risk_level': 'High',
                    'processes': ['/tmp/suspicious_process']
                }
            ]
            
            # Anomaly detection
            heuristic_results['anomalies'] = [
                'Unusual file sizes',
                'Suspicious file names',
                'Abnormal network traffic',
                'Unexpected process behavior',
                'Modified system files'
            ]
            
            # Risk scores
            heuristic_results['risk_scores'] = {
                '/tmp/suspicious_binary': 85,
                '/var/tmp/unknown_file': 60,
                '/home/user/downloaded_file': 45
            }
            
        except Exception as e:
            heuristic_results['error'] = str(e)
        
        return heuristic_results
    
    async def _behavioral_scan(self, target: str) -> Dict[str, Any]:
        """Behavioral malware analysis"""
        behavioral_results = {
            'monitored_processes': [],
            'network_activity': [],
            'file_activity': [],
            'system_changes': [],
            'api_calls': [],
            'persistence_mechanisms': []
        }
        
        try:
            # Monitored processes
            behavioral_results['monitored_processes'] = [
                {
                    'pid': 1234,
                    'name': 'suspicious_process',
                    'path': '/tmp/suspicious_binary',
                    'cpu_usage': 85.5,
                    'memory_usage': 256000,
                    'network_connections': 5
                }
            ]
            
            # Network activity
            behavioral_results['network_activity'] = [
                {
                    'process': 'suspicious_process',
                    'destination': '192.168.1.100:8080',
                    'protocol': 'TCP',
                    'bytes_sent': 1024,
                    'bytes_received': 2048
                }
            ]
            
            # File activity
            behavioral_results['file_activity'] = [
                {
                    'process': 'suspicious_process',
                    'action': 'write',
                    'file': '/etc/passwd',
                    'timestamp': datetime.now().isoformat()
                },
                {
                    'process': 'suspicious_process',
                    'action': 'delete',
                    'file': '/var/log/auth.log',
                    'timestamp': datetime.now().isoformat()
                }
            ]
            
            # System changes
            behavioral_results['system_changes'] = [
                {
                    'type': 'registry_modification',
                    'key': 'HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
                    'value': 'malware_persistence'
                },
                {
                    'type': 'service_installation',
                    'service': 'suspicious_service',
                    'path': '/tmp/suspicious_binary'
                }
            ]
            
            # Persistence mechanisms
            behavioral_results['persistence_mechanisms'] = [
                {
                    'method': 'Cron job',
                    'location': '/etc/crontab',
                    'command': '/tmp/suspicious_binary'
                },
                {
                    'method': 'Startup script',
                    'location': '/etc/init.d/suspicious_service',
                    'command': '/tmp/suspicious_binary'
                }
            ]
            
        except Exception as e:
            behavioral_results['error'] = str(e)
        
        return behavioral_results
    
    async def _yara_scan(self, target: str) -> Dict[str, Any]:
        """YARA-based malware detection"""
        yara_results = {
            'rules_loaded': 0,
            'matches': [],
            'rule_categories': [],
            'scan_statistics': {}
        }
        
        try:
            # Load YARA rules
            yara_results['rules_loaded'] = len(self.yara_rules)
            yara_results['rule_categories'] = list(self.yara_rules.keys())
            
            # Simulate YARA scanning
            for rule_name, rule_info in self.yara_rules.items():
                # This would normally involve actual YARA scanning
                # For demonstration, we'll simulate some matches
                if rule_name == 'generic_malware':
                    yara_results['matches'].append({
                        'rule': rule_name,
                        'file': '/tmp/suspicious_script',
                        'strings': ['wget http', 'chmod +x'],
                        'tags': ['malware', 'suspicious']
                    })
                elif rule_name == 'backdoor_indicators':
                    yara_results['matches'].append({
                        'rule': rule_name,
                        'file': '/var/tmp/backdoor',
                        'strings': ['nc -l -p', 'bash -i'],
                        'tags': ['backdoor', 'remote_access']
                    })
            
            # Scan statistics
            yara_results['scan_statistics'] = {
                'files_scanned': 1000,
                'rules_matched': len(yara_results['matches']),
                'scan_time': 45.2
            }
            
        except Exception as e:
            yara_results['error'] = str(e)
        
        return yara_results
    
    async def _hash_analysis(self, target: str) -> Dict[str, Any]:
        """Hash-based malware analysis"""
        hash_results = {
            'computed_hashes': [],
            'known_malware': [],
            'hash_databases': [],
            'reputation_scores': {}
        }
        
        try:
            # Hash databases
            hash_results['hash_databases'] = [
                'VirusTotal',
                'Malware Hash Registry',
                'Team Cymru',
                'Custom hash database'
            ]
            
            # Simulate hash computation and lookup
            suspicious_files = [
                '/tmp/suspicious_binary',
                '/var/tmp/unknown_file',
                '/home/user/downloaded_file'
            ]
            
            for file_path in suspicious_files:
                # This would normally involve actual file hashing
                # For demonstration, we'll simulate hash computation
                file_hash = {
                    'file': file_path,
                    'md5': 'a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6',
                    'sha1': 'a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0',
                    'sha256': 'a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2'
                }
                hash_results['computed_hashes'].append(file_hash)
                
                # Check against known malware hashes
                if file_path == '/tmp/suspicious_binary':
                    hash_results['known_malware'].append({
                        'file': file_path,
                        'family': 'Mirai',
                        'hash_type': 'md5',
                        'hash_value': file_hash['md5']
                    })
                
                # Reputation scores
                hash_results['reputation_scores'][file_path] = {
                    'reputation': 'malicious' if file_path == '/tmp/suspicious_binary' else 'suspicious',
                    'score': 95 if file_path == '/tmp/suspicious_binary' else 60,
                    'sources': ['VirusTotal', 'Custom DB']
                }
            
        except Exception as e:
            hash_results['error'] = str(e)
        
        return hash_results
    
    async def _threat_intelligence_lookup(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Threat intelligence lookup"""
        threat_intel = {
            'feeds': [],
            'iocs': [],
            'attribution': [],
            'campaigns': [],
            'recommendations': []
        }
        
        try:
            # Threat intelligence feeds
            threat_intel['feeds'] = [
                'MISP',
                'VirusTotal',
                'AlienVault OTX',
                'Threat Connect',
                'Custom feeds'
            ]
            
            # Indicators of Compromise
            threat_intel['iocs'] = [
                {
                    'type': 'file_hash',
                    'value': 'a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6',
                    'description': 'Mirai botnet binary'
                },
                {
                    'type': 'ip_address',
                    'value': '192.168.1.100',
                    'description': 'Command and control server'
                },
                {
                    'type': 'domain',
                    'value': 'malicious-domain.com',
                    'description': 'Malware download site'
                }
            ]
            
            # Attribution
            threat_intel['attribution'] = [
                {
                    'family': 'Mirai',
                    'actor': 'Unknown',
                    'country': 'Unknown',
                    'motivation': 'Financial'
                }
            ]
            
            # Campaigns
            threat_intel['campaigns'] = [
                {
                    'name': 'IoT Botnet Campaign',
                    'start_date': '2023-01-01',
                    'end_date': 'Ongoing',
                    'targets': ['IoT devices', 'Linux servers']
                }
            ]
            
        except Exception as e:
            threat_intel['error'] = str(e)
        
        return threat_intel
    
    def _compile_suspicious_files(self, results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Compile list of suspicious files"""
        suspicious_files = []
        
        # From file scan
        if 'file_scan' in results:
            file_scan = results['file_scan']
            for file_info in file_scan.get('suspicious_files', []):
                suspicious_files.append({
                    'source': 'file_scan',
                    'file': file_info,
                    'reason': 'Suspicious file pattern'
                })
        
        # From signature scan
        if 'signature_scan' in results:
            signature_scan = results['signature_scan']
            for match in signature_scan.get('matches', []):
                suspicious_files.append({
                    'source': 'signature_scan',
                    'file': match['file_path'],
                    'reason': f"Malware signature match: {match['family']}"
                })
        
        # From YARA scan
        if 'yara_scan' in results:
            yara_scan = results['yara_scan']
            for match in yara_scan.get('matches', []):
                suspicious_files.append({
                    'source': 'yara_scan',
                    'file': match['file'],
                    'reason': f"YARA rule match: {match['rule']}"
                })
        
        # From hash analysis
        if 'hash_analysis' in results:
            hash_analysis = results['hash_analysis']
            for malware in hash_analysis.get('known_malware', []):
                suspicious_files.append({
                    'source': 'hash_analysis',
                    'file': malware['file'],
                    'reason': f"Known malware hash: {malware['family']}"
                })
        
        return suspicious_files
    
    def _generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate malware scan recommendations"""
        recommendations = []
        
        if results.get('suspicious_files'):
            recommendations.append("Quarantine and analyze all suspicious files")
        
        if results.get('malware_families'):
            recommendations.append("Implement specific protections against identified malware families")
        
        recommendations.extend([
            "Install and maintain updated antivirus software",
            "Implement real-time file monitoring",
            "Regular system scans and updates",
            "Network segmentation and monitoring",
            "User education and awareness training",
            "Backup and recovery procedures",
            "Incident response planning",
            "Threat intelligence integration",
            "Log monitoring and analysis",
            "Endpoint detection and response (EDR) implementation"
        ])
        
        return recommendations