#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Author: Hayk Jomardyan
#
"""
Vulnerability scanner with CVE-based detection
"""

import asyncio
import aiohttp
import json
import re
from datetime import datetime
from typing import Dict, List, Any, Optional
# Removed unused import: timedelta
from .base_scanner import BaseScannerModule


class VulnerabilityScanner(BaseScannerModule):
    """CVE-based vulnerability scanner"""
    
    def __init__(self, timeout: int = 30, use_nvd: bool = True, use_cve_mitre: bool = True):
        super().__init__("vulnerability_scanner", timeout)
        self.use_nvd = use_nvd
        self.use_cve_mitre = use_cve_mitre
        self.cve_cache = {}
        self.last_cache_update = None
        
        # Common vulnerability patterns
        self.vuln_patterns = {
            'ssh': {
                'OpenSSH_7.4': [
                    {'cve': 'CVE-2018-15473', 'severity': 'Medium', 'description': 'User enumeration vulnerability'},
                    {'cve': 'CVE-2018-20685', 'severity': 'High', 'description': 'scp client writes to arbitrary files'}
                ],
                'OpenSSH_6.6': [
                    {'cve': 'CVE-2016-0777', 'severity': 'High', 'description': 'Information disclosure vulnerability'},
                    {'cve': 'CVE-2016-0778', 'severity': 'High', 'description': 'Buffer overflow vulnerability'}
                ],
                'OpenSSH_5.3': [
                    {'cve': 'CVE-2010-4478', 'severity': 'Medium', 'description': 'Authentication bypass vulnerability'}
                ]
            },
            'apache': {
                'Apache/2.4.29': [
                    {'cve': 'CVE-2018-1312', 'severity': 'Medium', 'description': 'Weak digest authentication'},
                    {'cve': 'CVE-2017-15715', 'severity': 'High', 'description': 'Expression injection vulnerability'}
                ],
                'Apache/2.2.22': [
                    {'cve': 'CVE-2012-0883', 'severity': 'High', 'description': 'Improper TE header handling'},
                    {'cve': 'CVE-2011-3607', 'severity': 'Medium', 'description': 'Integer overflow vulnerability'}
                ]
            },
            'nginx': {
                'nginx/1.10.3': [
                    {'cve': 'CVE-2017-7529', 'severity': 'High', 'description': 'Integer overflow in range filter'}
                ],
                'nginx/1.6.2': [
                    {'cve': 'CVE-2016-0747', 'severity': 'High', 'description': 'Use-after-free vulnerability'}
                ]
            },
            'mysql': {
                'MySQL 5.6': [
                    {'cve': 'CVE-2018-2767', 'severity': 'Medium', 'description': 'InnoDB vulnerability'},
                    {'cve': 'CVE-2017-3636', 'severity': 'High', 'description': 'Client mysqldump vulnerability'}
                ],
                'MySQL 5.5': [
                    {'cve': 'CVE-2016-6663', 'severity': 'High', 'description': 'Race condition privilege escalation'}
                ]
            },
            'postgresql': {
                'PostgreSQL 9.6': [
                    {'cve': 'CVE-2018-1058', 'severity': 'High', 'description': 'Schema search path vulnerability'}
                ],
                'PostgreSQL 9.3': [
                    {'cve': 'CVE-2014-0060', 'severity': 'Medium', 'description': 'Privilege escalation vulnerability'}
                ]
            },
            'ftp': {
                'vsftpd 2.3.4': [
                    {'cve': 'CVE-2011-2523', 'severity': 'Critical', 'description': 'Backdoor command execution'}
                ],
                'ProFTPD 1.3.3c': [
                    {'cve': 'CVE-2010-4221', 'severity': 'High', 'description': 'Buffer overflow vulnerability'}
                ]
            },
            'smtp': {
                'Postfix 2.11': [
                    {'cve': 'CVE-2014-8564', 'severity': 'Medium', 'description': 'SMTP injection vulnerability'}
                ],
                'Sendmail 8.14': [
                    {'cve': 'CVE-2014-3956', 'severity': 'High', 'description': 'Remote code execution'}
                ]
            }
        }
    
    async def scan(self, target: str, services: Optional[Dict[int, Dict]] = None,
                   check_exploits: bool = True, **kwargs) -> Dict[str, Any]:
        """
        Comprehensive vulnerability scan
        """
        self.log_scan_start(target)
        
        results = {
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': [],
            'critical_vulns': [],
            'high_vulns': [],
            'medium_vulns': [],
            'low_vulns': [],
            'info_vulns': [],
            'exploits_available': [],
            'security_score': 0,
            'recommendations': []
        }
        
        try:
            if services:
                # Check vulnerabilities for detected services
                for port, service_info in services.items():
                    service_vulns = await self._check_service_vulnerabilities(
                        target, port, service_info
                    )
                    results['vulnerabilities'].extend(service_vulns)
            
            # Check for common system vulnerabilities
            system_vulns = await self._check_system_vulnerabilities(target)
            results['vulnerabilities'].extend(system_vulns)
            
            # Check for configuration vulnerabilities
            config_vulns = await self._check_configuration_vulnerabilities(target)
            results['vulnerabilities'].extend(config_vulns)
            
            # Check for web application vulnerabilities
            web_vulns = await self._check_web_vulnerabilities(target)
            results['vulnerabilities'].extend(web_vulns)
            
            # Categorize vulnerabilities by severity
            self._categorize_vulnerabilities(results)
            
            # Check for available exploits
            if check_exploits:
                exploits = await self._check_exploits(results['vulnerabilities'])
                results['exploits_available'] = exploits
            
            # Calculate security score
            results['security_score'] = self._calculate_security_score(results)
            
            # Generate recommendations
            results['recommendations'] = self._generate_recommendations(results)
            
        except Exception as e:
            self.logger.error(f"Error during vulnerability scan of {target}: {str(e)}")
            results['error'] = str(e)
        
        self.log_scan_end(target)
        return results
    
    async def _check_service_vulnerabilities(self, target: str, port: int, 
                                           service_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check vulnerabilities for specific services"""
        vulnerabilities = []
        
        service_name = service_info.get('name', '').lower()
        service_version = service_info.get('version', '')
        service_product = service_info.get('product', '')
        banner = service_info.get('banner', '')
        
        # Check against known vulnerable versions
        for service_type, versions in self.vuln_patterns.items():
            if service_type in service_name or service_type in service_product.lower():
                for version_pattern, vulns in versions.items():
                    if self._version_matches(service_version, version_pattern) or \
                       version_pattern.lower() in banner.lower():
                        for vuln in vulns:
                            vulnerability = {
                                'port': port,
                                'service': service_name,
                                'version': service_version,
                                'cve': vuln['cve'],
                                'severity': vuln['severity'],
                                'description': vuln['description'],
                                'cvss_score': self._get_cvss_score(vuln['severity']),
                                'target': target,
                                'discovered_at': datetime.now().isoformat()
                            }
                            vulnerabilities.append(vulnerability)
        
        # Check for SSL/TLS vulnerabilities
        if port in [443, 8443] or 'https' in service_name:
            ssl_vulns = await self._check_ssl_vulnerabilities(target, port)
            vulnerabilities.extend(ssl_vulns)
        
        # Check for specific service vulnerabilities
        if service_name == 'ssh':
            ssh_vulns = await self._check_ssh_vulnerabilities(target, port, service_version)
            vulnerabilities.extend(ssh_vulns)
        elif service_name in ['http', 'https']:
            http_vulns = await self._check_http_vulnerabilities(target, port)
            vulnerabilities.extend(http_vulns)
        elif service_name == 'ftp':
            ftp_vulns = await self._check_ftp_vulnerabilities(target, port)
            vulnerabilities.extend(ftp_vulns)
        
        return vulnerabilities
    
    async def _check_system_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Check for system-level vulnerabilities"""
        vulnerabilities = []
        
        # Check for common system vulnerabilities
        system_checks = [
            self._check_kernel_vulnerabilities,
            self._check_privilege_escalation,
            self._check_file_permissions,
            self._check_weak_credentials,
            self._check_network_services
        ]
        
        for check in system_checks:
            try:
                vulns = await check(target)
                vulnerabilities.extend(vulns)
            except Exception as e:
                self.logger.debug(f"System check failed: {str(e)}")
        
        return vulnerabilities
    
    async def _check_configuration_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Check for configuration vulnerabilities"""
        vulnerabilities = []
        
        # Check for common misconfigurations
        config_checks = [
            self._check_default_credentials,
            self._check_unnecessary_services,
            self._check_weak_encryption,
            self._check_missing_patches,
            self._check_insecure_protocols
        ]
        
        for check in config_checks:
            try:
                vulns = await check(target)
                vulnerabilities.extend(vulns)
            except Exception as e:
                self.logger.debug(f"Configuration check failed: {str(e)}")
        
        return vulnerabilities
    
    async def _check_web_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Check for web application vulnerabilities"""
        vulnerabilities = []
        
        # Test for common web vulnerabilities
        web_checks = [
            self._check_sql_injection,
            self._check_xss_vulnerabilities,
            self._check_directory_traversal,
            self._check_command_injection,
            self._check_file_upload_vulnerabilities,
            self._check_csrf_vulnerabilities
        ]
        
        for check in web_checks:
            try:
                vulns = await check(target)
                vulnerabilities.extend(vulns)
            except Exception as e:
                self.logger.debug(f"Web vulnerability check failed: {str(e)}")
        
        return vulnerabilities
    
    async def _check_ssl_vulnerabilities(self, target: str, port: int) -> List[Dict[str, Any]]:
        """Check for SSL/TLS vulnerabilities"""
        vulnerabilities = []
        
        try:
            import ssl
            import socket
            
            # Check for weak ciphers
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            # Test various SSL/TLS versions
            ssl_versions = [
                (ssl.PROTOCOL_TLSv1, "TLSv1.0"),
                (ssl.PROTOCOL_TLSv1_1, "TLSv1.1"),
                (ssl.PROTOCOL_TLSv1_2, "TLSv1.2")
            ]
            
            for protocol, version_name in ssl_versions:
                try:
                    test_context = ssl.SSLContext(protocol)
                    test_context.check_hostname = False
                    test_context.verify_mode = ssl.CERT_NONE
                    
                    with socket.create_connection((target, port), timeout=5) as sock:
                        with test_context.wrap_socket(sock) as ssock:
                            cipher = ssock.cipher()
                            if cipher:
                                cipher_name = cipher[0]
                                # Check for weak ciphers
                                if any(weak in cipher_name.lower() for weak in ['rc4', 'des', 'md5', 'sha1']):
                                    vulnerabilities.append({
                                        'port': port,
                                        'service': 'SSL/TLS',
                                        'cve': 'N/A',
                                        'severity': 'Medium',
                                        'description': f'Weak cipher {cipher_name} supported',
                                        'cvss_score': 5.0,
                                        'target': target,
                                        'discovered_at': datetime.now().isoformat()
                                    })
                                
                                # Check for deprecated SSL versions
                                if version_name in ['TLSv1.0', 'TLSv1.1']:
                                    vulnerabilities.append({
                                        'port': port,
                                        'service': 'SSL/TLS',
                                        'cve': 'N/A',
                                        'severity': 'Medium',
                                        'description': f'Deprecated SSL version {version_name} supported',
                                        'cvss_score': 5.0,
                                        'target': target,
                                        'discovered_at': datetime.now().isoformat()
                                    })
                except:
                    pass
        
        except Exception as e:
            self.logger.debug(f"SSL vulnerability check failed: {str(e)}")
        
        return vulnerabilities
    
    async def _check_ssh_vulnerabilities(self, target: str, port: int, version: str) -> List[Dict[str, Any]]:
        """Check for SSH-specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            import paramiko
            
            # Test SSH configuration
            ssh_client = paramiko.SSHClient()
            ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            try:
                transport = paramiko.Transport((target, port))
                transport.connect()
                
                # Check for weak key exchange algorithms
                kex_algos = transport.get_security_options().kex
                weak_kex = ['diffie-hellman-group1-sha1', 'diffie-hellman-group14-sha1']
                
                for algo in kex_algos:
                    if algo in weak_kex:
                        vulnerabilities.append({
                            'port': port,
                            'service': 'SSH',
                            'cve': 'N/A',
                            'severity': 'Medium',
                            'description': f'Weak key exchange algorithm: {algo}',
                            'cvss_score': 5.0,
                            'target': target,
                            'discovered_at': datetime.now().isoformat()
                        })
                
                transport.close()
                
            except Exception as e:
                self.logger.debug(f"SSH security check failed: {str(e)}")
        
        except ImportError:
            pass
        
        return vulnerabilities
    
    async def _check_http_vulnerabilities(self, target: str, port: int) -> List[Dict[str, Any]]:
        """Check for HTTP-specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:
                url = f"http://{target}:{port}"
                
                # Check for HTTP security headers
                async with session.get(url) as response:
                    headers = response.headers
                    
                    # Check for missing security headers
                    security_headers = {
                        'X-Content-Type-Options': 'nosniff',
                        'X-Frame-Options': 'DENY',
                        'X-XSS-Protection': '1; mode=block',
                        'Strict-Transport-Security': None,
                        'Content-Security-Policy': None
                    }
                    
                    for header, expected_value in security_headers.items():
                        if header not in headers:
                            vulnerabilities.append({
                                'port': port,
                                'service': 'HTTP',
                                'cve': 'N/A',
                                'severity': 'Low',
                                'description': f'Missing security header: {header}',
                                'cvss_score': 3.0,
                                'target': target,
                                'discovered_at': datetime.now().isoformat()
                            })
                    
                    # Check for information disclosure
                    server_header = headers.get('Server', '')
                    if server_header:
                        vulnerabilities.append({
                            'port': port,
                            'service': 'HTTP',
                            'cve': 'N/A',
                            'severity': 'Info',
                            'description': f'Server information disclosure: {server_header}',
                            'cvss_score': 1.0,
                            'target': target,
                            'discovered_at': datetime.now().isoformat()
                        })
        
        except Exception as e:
            self.logger.debug(f"HTTP vulnerability check failed: {str(e)}")
        
        return vulnerabilities
    
    async def _check_ftp_vulnerabilities(self, target: str, port: int) -> List[Dict[str, Any]]:
        """Check for FTP-specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            import ftplib
            
            # Test anonymous FTP access
            ftp = ftplib.FTP()
            ftp.connect(target, port, timeout=5)
            
            try:
                ftp.login('anonymous', 'anonymous@example.com')
                vulnerabilities.append({
                    'port': port,
                    'service': 'FTP',
                    'cve': 'N/A',
                    'severity': 'Medium',
                    'description': 'Anonymous FTP access allowed',
                    'cvss_score': 5.0,
                    'target': target,
                    'discovered_at': datetime.now().isoformat()
                })
                ftp.quit()
            except:
                ftp.close()
        
        except Exception as e:
            self.logger.debug(f"FTP vulnerability check failed: {str(e)}")
        
        return vulnerabilities
    
    async def _check_kernel_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Check for kernel vulnerabilities"""
        # This would require remote access to check kernel version
        # For now, return empty list
        return []
    
    async def _check_privilege_escalation(self, target: str) -> List[Dict[str, Any]]:
        """Check for privilege escalation vulnerabilities"""
        # This would require detailed system access
        return []
    
    async def _check_file_permissions(self, target: str) -> List[Dict[str, Any]]:
        """Check for file permission vulnerabilities"""
        # This would require file system access
        return []
    
    async def _check_weak_credentials(self, target: str) -> List[Dict[str, Any]]:
        """Check for weak credentials"""
        # This would involve brute force testing
        return []
    
    async def _check_network_services(self, target: str) -> List[Dict[str, Any]]:
        """Check for network service vulnerabilities"""
        # This would involve detailed network analysis
        return []
    
    async def _check_default_credentials(self, target: str) -> List[Dict[str, Any]]:
        """Check for default credentials"""
        # This would involve testing common default passwords
        return []
    
    async def _check_unnecessary_services(self, target: str) -> List[Dict[str, Any]]:
        """Check for unnecessary services"""
        # This would require service enumeration
        return []
    
    async def _check_weak_encryption(self, target: str) -> List[Dict[str, Any]]:
        """Check for weak encryption"""
        # This would involve cryptographic analysis
        return []
    
    async def _check_missing_patches(self, target: str) -> List[Dict[str, Any]]:
        """Check for missing patches"""
        # This would require patch level analysis
        return []
    
    async def _check_insecure_protocols(self, target: str) -> List[Dict[str, Any]]:
        """Check for insecure protocols"""
        # This would involve protocol analysis
        return []
    
    async def _check_sql_injection(self, target: str) -> List[Dict[str, Any]]:
        """Check for SQL injection vulnerabilities"""
        # This would involve web application testing
        return []
    
    async def _check_xss_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Check for XSS vulnerabilities"""
        # This would involve web application testing
        return []
    
    async def _check_directory_traversal(self, target: str) -> List[Dict[str, Any]]:
        """Check for directory traversal vulnerabilities"""
        # This would involve web application testing
        return []
    
    async def _check_command_injection(self, target: str) -> List[Dict[str, Any]]:
        """Check for command injection vulnerabilities"""
        # This would involve web application testing
        return []
    
    async def _check_file_upload_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Check for file upload vulnerabilities"""
        # This would involve web application testing
        return []
    
    async def _check_csrf_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Check for CSRF vulnerabilities"""
        # This would involve web application testing
        return []
    
    async def _check_exploits(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Check for available exploits"""
        exploits = []
        
        for vuln in vulnerabilities:
            cve = vuln.get('cve', '')
            if cve and cve != 'N/A':
                # Check exploit databases (would require API access)
                exploit_info = {
                    'cve': cve,
                    'exploit_available': False,
                    'exploit_references': []
                }
                exploits.append(exploit_info)
        
        return exploits
    
    def _version_matches(self, version: str, pattern: str) -> bool:
        """Check if version matches pattern"""
        if not version or not pattern:
            return False
        
        # Simple version matching
        return pattern.lower() in version.lower()
    
    def _get_cvss_score(self, severity: str) -> float:
        """Get CVSS score from severity"""
        severity_scores = {
            'Critical': 9.0,
            'High': 7.0,
            'Medium': 5.0,
            'Low': 3.0,
            'Info': 1.0
        }
        return severity_scores.get(severity, 0.0)
    
    def _categorize_vulnerabilities(self, results: Dict[str, Any]):
        """Categorize vulnerabilities by severity"""
        for vuln in results['vulnerabilities']:
            severity = vuln.get('severity', 'Info')
            if severity == 'Critical':
                results['critical_vulns'].append(vuln)
            elif severity == 'High':
                results['high_vulns'].append(vuln)
            elif severity == 'Medium':
                results['medium_vulns'].append(vuln)
            elif severity == 'Low':
                results['low_vulns'].append(vuln)
            else:
                results['info_vulns'].append(vuln)
    
    def _calculate_security_score(self, results: Dict[str, Any]) -> int:
        """Calculate security score based on vulnerabilities"""
        base_score = 100
        
        # Deduct points based on vulnerability severity
        base_score -= len(results['critical_vulns']) * 20
        base_score -= len(results['high_vulns']) * 10
        base_score -= len(results['medium_vulns']) * 5
        base_score -= len(results['low_vulns']) * 2
        base_score -= len(results['info_vulns']) * 1
        
        return max(0, base_score)
    
    def _generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        if results['critical_vulns']:
            recommendations.append("CRITICAL: Address critical vulnerabilities immediately")
        
        if results['high_vulns']:
            recommendations.append("HIGH: Prioritize high-severity vulnerabilities")
        
        if results['medium_vulns']:
            recommendations.append("MEDIUM: Address medium-severity vulnerabilities")
        
        if results['low_vulns']:
            recommendations.append("LOW: Consider addressing low-severity vulnerabilities")
        
        # Add specific recommendations
        recommendations.extend([
            "Keep software and systems updated",
            "Implement strong authentication mechanisms",
            "Use encryption for sensitive data",
            "Regular security audits and penetration testing",
            "Monitor system logs for suspicious activity"
        ])
        
        return recommendations